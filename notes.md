# Chess Project Notes

- Use git mv instead of mv to rename/move files, use git rm to remove files. git rm --cached removes a file from
  repository only.
- Math methods allow for safer calculations, bigger numbers.
- final keyword declares a constant variable. It must be declared by the end of the constructor.
- Variables must be initialized before use.
- A package is a set of related classes.
- Static methods are not attached to any object.
- Casting is done by adding (type) to the beginning ex. (float) 3.14
- Use .equals() to compare strings, not ==, except for checking nullity.
- Integer.toString() converts an int to a string, Integer.parseInt() converts a string to an int.
- Strings are immutable.
- Adding \s to the end of a string preserves trailing spaces.
- var declaration allows for generic typing.
- To read input, create a new Scanner(System.in).
- scannerName.nextLine() reads next line, next() reads next word, nextInt(), etc.
- System.console() is slightly safer because of array storage overwrites.
- System.out.println() prints with newline, print() prints with no newline.
- Printf format string: % precedes a one-letter type identifier (f,s,d, etc.), .#f with a number allows shortened
  precision.
- Using L/f/d ending tags for long/float/double literals saves runtime and prevents errors.
- String.format() can use formatted strings to combine/format strings.
- Using the new String() constructor negates the benefits of interning/string optimization. 
- Special characters: \n, \t, \", \', \\, \b, \uXXXX
- String concatenation is inefficient because it creates new strings, so use a StringBuilder.
- If, else if, else are normal, can be shortened with ? : .
- Constructors have no return type, have the same name as class.
- StringBuilder class allows you to modify the string over time.
- Arrays are allocated similar to cpp, but the type is Type[] instead of Type*.
- Switches map inputs to outputs : switch (input) { case value[, value2, ...] -> output var or statement; ... default ->
  {if it's a block, it must have a yield.} } Nulls can cause errors, so have a case null. Switches can fall-through (
  execute following cases until stopped) by using : instead of -> and using yield or break to stop falling.
- Labeled break statements can jump out of multiple loops. Syntax: breakLabel: {code} break breakLabel;
- Variables in overlapping scopes must have unique names.
- All arrays have default values, except for objects, where the array is full of null references.
- Arrays have fixed sizes, ArrayLists don't.
- Classes can be typed like C++.
- Elements can be added with .add([index], val) and removed with .remove([index], val), .get(index) gets a value, .set(
  index, value) sets a value.
- ArrayLists cannot have primitive types, so they use wrappers, such as Integer. .equals() must be used to check
  equality with these, as == compares references.
- Arrays are passed by reference, so separating them requires using Arrays.copyOf(array, length).
- To copy an ArrayList, you can use new ArrayList<type>(arrayList);, or List.of(array).
- Arrays have methods like fill and sort, to use these for ArrayLists use Collections class.
- Args start at 0, without the program name included.
- Arrays.deepToString(array) prints nested lists.
- Each function must specify publicity and return type, and if it is static.
- Varargs are declared as the last parameter using method(type... name)
- InputStream and OutputStream objects are created using Files.newInputStream(path);
- stream.read() reads a single byte, .readAllBytes() reads all bytes (can also be done with Files.readAllBytes(path)),
  or read N number of bytes with .readNBytes(), skipping N bytes with skipNBytes()
- .write() can write bytes/byte arrays, but it must be closed, which can be done using a try-with-resources statement.
  An input stream can be transferred to an output stream by using in.transferTo(out). Files can be copied using
  Files.copy(path, out)
- Encoding can be specified with a Charset object, found in StandardCharsets or with Charset.forName("name")
- Text can be read using a reader, such as with a new InputStreamReader(stream, charset). Short text can be read with
  Files.readString(path, charset), or a sequence of lines as Files.readAllLines(path,charset). Large files can be
  processed as a Stream<String> with Files.lines(path, charset) and a try-with-resources. To read numbers or words, use
  a scanner and its delimiter.
- To read from a file, use Files.newBufferedReader(). To read from a non-file, wrap an inputStream in a new BufferedReader(stream).
- To write text, use an OutputStreamWriter(stream, charset) and out.write(str). For a file, use Files.newBufferedWriter(path, charset).
- For convenience, use a new PrintWriter(streamWriter) to get print methods.
- To write a preprepared string, use Files.write/writeString(path,string,charset,[StandardOpenOption.APPEND])
- You can lock files using FileChannel and FileLock classes.
- File paths can be created using the Path.of() method.
- Paths can be combined using path.resolve(secondPath). path.relativize returns the relative path from one to another.
- Working directory can be fetched using System.getProperty("user.dir").
- To create a new directory, use Files.createDirectory(path). For multiple, use Files.createDirectories(path). To create a file. use Files.createFile(path). Files.exists checks if it exists. Temp files/directories can be created using createTempFile(path, prefix, suffix), etc.
- To copy, use Files.copy(from, to). To move, use Files.move(from, to). Replace existing and copy attributes can be included as params with StandardCopyOption.REPLACE_EXISTING, etc.
- Files.delete(path) deletes a file.
- Files.list(path) lists all files as a Stream of paths, should be opened as try-with-resources. Depth-first.
- Imports don't increase size of compiled files. They appear after package but before class declarations. * imports all packages, but not subpackages. No import is needed for classes in java.lang or in the same package.
- Classpath manages directories for packages
- Variables can only store objects by reference. Mutators modify the original object, while accessors return new ones.
- Parameters are always passed by value.
- Overloaded methods are multiple methods with the same name but different parameters.
- Instance variables are automatically set to 0/false/null.
- Default values are specified when a variable is initialized.
- Records are immutable public classes for simple implementations
- Static initialization blocks can initialize a static variable upon creation of the class. Static variables are class variables, the same between instances.
- Not specifying public or private gives an item package access - everything in the package can use it.
- Import static allows you to import static methods and variables.
- Inner classes have access to all outer methods and variables.
- Constructors invoke each other with this() and the parent's constructor with super(); Constructors have no return type and the name matches the class.
- Inheritance: is-a, use the keyword "extends". All instance variables are inherited, even private ones. All non-private, non-static methods are inherited.
- To override a method, you must have the same arguments, return type, same or looser access modifier, and same or more specific exceptions. Overridden methods can be called using super, and @Override is used as a sanity check. Children must be substitutable for parents.
- Final methods can't be overridden.
- If methods are declared in an enum, a semicolon must follow the values that precede the method.
- Classes: Keep data private, one responsibility per class, classes have noun names while methods have verb names, static methods should be used sparingly.
- Records need all parameters, have only one constructor, have automatic getters, equals, hashCode, and toString methods.
- Getters in records are just the field names e.g. p.name().
- To change records, add a method inside the braces that returns a new record with updated data.
- Exceptions are constructed with `new` and the parameter being an error message. `throw` throws an exception.
- Errors are from the language, exceptions are from the programmer.
- Unchecked exceptions are subclasses of RuntimeException, and all other exceptions are checked.
- Unchecked exceptions are not checked during compilation. Checked exceptions are used when failure is anticipated. Unchecked exceptions are the programmer's fault.
- You can make your own exception classes by extending Exception, RuntimeException, etc.
- Possible exceptions must be declared for a method in the header using `throws` followed by the exception classes.
- Overwritten methods cannot throw more kinds of exceptions than their parent.
- Catch exceptions using a try-catch statement, with one or multiple handlers. Catch clauses are matched top to bottom, so the most specific exception should come first.
- Try-with-resources ensures open hooks are closed in case of exceptions. Resources must include the AutoCloseable interface. Multiple resources can be separated with semicolons, and they will be closed in reverse order.
- Suppressed exceptions are exceptions caused by another exception or handling of it. You can use methods to find suppressed exceptions and causes of rethrown exceptions.
- `finally` clauses are run after try-catch statements finish. It is only for closing resources, not changing the control flow by returning or breaking or throwing exceptions.
- Use the Thread class's method to set a default uncaught exception handler.
- Crashing is never acceptable!
- Exceptions have a printStackTrace() method that is useful.
- Interfaces define methods that subclasses must implement. They're a set of methods that a class promises to implement. All methods are public. Default implementations in the interface are optional, and methods must be prefaced with the `default` tag in the declaration.
- Unimplemented methods in an interface are called abstract.
- Interface declaration: public interface Name {}. public class ClassName implements Name {}
- Interfaces can be used in place of specific classes for variable types, as long as the class of the object referenced by the variable implements it. All objects, however, must be instances of classes.
- Casting is done by doing `(type) varName`, which can be done to access new methods from the subtype that are not in the supertype.
- `instanceof` is an operator checking if an object is a certain type, and it is null-safe. `varName instanceof typeName` returns a boolean.
- Checking the instance type and then casting can be done with `varName instanceof typeName var2Name` where var2Name is a new variable that can be used immediately.
- Interfaces can extend each other. Classes can implement multiple interfaces.
- Interface variables are automatically public, static, and final.
- To specify which superclass you are using a method from, use SuperClassName,super,method() syntax.
- Private interface methods are possible, but cannot be defaults, so they're only helper methods.
- A generic type is done in angle brackets in declarations and used throughout the class, like `public interface Collections<T>`
- The .compare() method safely compares numbers with regards to overflow, infinite values, and NaN.
- Objects can access private features of any instance of their class.
- Subclasses cannot access private features of superclasses.
- Overriden methods must have the same parameters as the default method. This can be checked using @Override tag.
- Dynamic method lookup means subclass instances assigned to superclass variables will still use the overridden methods of the subclass. Arrays function much the same way, but problems can be caused if superclass types are added to subclass arrays.
- Anonymous subclasses are made with braces after the object `new` statement, usually with modified methods or fields.
- Tagging a class definition with `abstract` means there is a method that subclasses must implement themselves. Objects cannot be created with an abstract class, but variables can have an abstract type.
- `protected` keyword grants package level access and access to subclasses from other packages.
- Sealed classes allow us to permit only certain subclasses or, by default, subclasses in the same file.
- `toString()` converts an object to string representation, to print arrays use `Arrays.deepToString()`
- `Objects.equals()` tests null safe equality.
- Interfaces cannot win over default toString, equals, and hashCode methods.
- The clone method should only be overridden to make deep copies.
- For enums, `valueOf()` is opposite to `toString()`
- `values()` returns an array containing all values of an enum.
- You can add override methods to each value of an enum, but the methods must be declared in the parent and overridden.
- You can use statics in an enum, but they must be declared after everything else in a static initializer.
- Two interfaces for data structures: Collection for collections, and Map for maps.
- Collections have a type parameter, and methods such as add, addAll, remove, removeAll, removeIf, retainAll, clear, size, isEmpty, contains, containsAll, iterator, fill, swap, shuffle, and toArray.
- SequencedCollections additionally have get, add, and remove for the first and last elements, as well as a reversed method to reverse the order.
- Lists have get, set, and remove methods, indexOf, lastIndexOf, replaceAll, sort, of (gives an unmodifiable list containing parameters provided), or subList.
- Arrays that allow fast random access implement the RandomAccess tagging interface.
- A deque is a double ended queue.
- Iterators have the hasNext, next, and remove methods. 
- ListIterators are used with LinkedLists
- Iterators on mutated sets may throw exceptions.
- For maps, use `put(key,value)` to insert a value. `get` gets a value from a key, `getOrDefault` is null-safe. `merge(key, valueToMerge, function)` merges values for things like counters. `computeIfAbsent` allows operations if a value has not yet been added. `forEach` allows you to iterate, and `keySet() values() entrySet()` ive you sets for their respective items. 
- Entries in sets generated by methods of the Map class are passed by reference and will mutate the original map. This can be changed by calling `copyOf()` on the entry.
- LinkedHashMaps retain order.
- Properties collections are used for configs. System.getProperties has lots of useful data.
- BitSet stores a sequence of bits efficiently, but it is not a collection.
- Enums have their own sets and maps.
- Deques are queues with efficient access to both ends.
- Use ArrayDeques for stacks.
- PriorityQueues are a provided class in Java.
- WeakHashMaps allow better garbage collection for references that have been removed everywhere else.
- Lists and sets can have sublists and subsets.
- Collections class has unmodifiable versions of data structures
- The concurrent package is better for concurrency than synchronized views.
- checkedLists allow for errors to be thrown for incorrect objects on insertion instead of retrieval.
- When placing objects in collections, equals() and hashCode() must be overwritten.
- Collections can only store objects, so wrappers are needed for primitives.
- HashSets are faster, TreeSets are less memory.
- Equals and hashCode methods need to be in sync, with the same fields and methodology.
- Sortable classes must implement Comparable, which has compareTo. 
- In compareTo, if two objects are equal, it returns zero. If the object being compared is less, it returns -1. If the object being compared is greater, it returns 1.
- Don't modify an object in a collection in a way that would change its position in the collection. Take it out, modify it, and put it back in.
- Immutable objects don't need to be copied, they can be passed by reference.
- One way to copy an object is to make a copy constructor that takes an object as a parameter and makes a new object that is exactly the same.
- To override `clone()`, a class must implement Cloneable and should probably catch CloneNotSupportedException.
- RuntimeExceptions are for bugs.
- To create a deep copy, make a shallow copy and then clone each mutable member field manually, setting the new object's field equal to the clone.
- When making clones, they must be cast into the correct type, because clone() returns an Object by default.
- Local classes are classes defined inside methods. Local classes are not declared as public or private. Local classes can access the variables of the enclosing scope.
- Define an anonymous class using `new [Interface]() {methods}`. Anonymous classes are only necessary when defining 2+ methods since you can't use a lambda.
- Static classes cannot access any instance variables, including of the outer class.
- Declare things as close as possible to where we use them.
- Variables used in local classes can't be changed after the instance of the class is created, because of garbage collection protection and copying.
- We want to create systems that work, are structured for ease of understanding/maintenance, and can hold up under change.
- Software design is a cycle of planning, implementing, and testing. You can;t cut out any step.
- Abstraction combats complexity. Some classes model real world concepts, some don't.
- Make the public-facing code as simple as possible. They shouldn't need to know what's inside.
- Store and do only what you need.
- Names should convey function and purpose.
- Class and variable names should be nouns, method names should be verbs.
- Each class and method should have one well-defined responsibility. All features should be related to that.
- Break a program into smaller problems, solve each, and them combine them to solve bigger problems.
- System -> Subsystem -> Package -> Class -> Method
- Choose good data structures and algorithms.
- Classes should know as little about each other as possible - low coupling. This reduces ripple changes.
- Everything should be private unless there's a good reason to make it public.
- Protected: Variable/method is only visible within the inheritance tree.
- Don't give away your implementations in names (security reasons).
- Separate an interface and its implementation. Program to interfaces instead of concrete classes.
- Don't repeat yourself.
- InputStream	Represents data as an unbounded incoming sequence of bytes. Is an interface.
- You can wrap an Input/OutputStream in filter Input/OutputStreams to create a pipeline.
- OutputStream	Represents data as an unbounded outgoing sequence of bytes.
- Convert streams to Readers/Writers using InputStreamReader/OutputStreamWriter.
- Reader	Provides functionality for reading an InputStream as characters.
- Writer	Provides functionality for writing characters to an output stream.
- FileInputStream	Stream that uses a file as its source of data.
- ByteArrayInputStream	Stream that uses a byte array as its source of data.
- BufferedReader/Writer	Reader that wraps another reader and caches the reader's data in an attempt to optimize performance. Should almost always be used for efficiency on first layer reader/writer.
- StringReader	Represents a String as an input reader.
- PrintStream/Writer	Output stream that provides print functions such as println or printf
- File	Provides basic directory and file operations such as create, exists, iterate, or delete. 
- file.exists(), file.createNewFile(), file.delete() on a File(path) object. Files.readAllLines(path) reads all lines of a file into a list.
- Scanner	Parses a file into Strings/tokens. Note that this class is in java.util.
- RandomAccessFile    Uses a pointer to read/write to any location within a file. seek() or skipBytes() move the pointer, then read or write.
- To use GSON, create a builder, create an object using the builder, use .fronJson(string, object type) to create a class instance, and .toJson(object) to create a JSON string.
- JsonParsers parse JSON into trees. A JsonElement can be made into a JsonObject and traversed with .get(key)
- To use GSON with custom classes, you need to create an adapter that extends TypeAdapter and override the read and write methods. Then, register the adapter with the builder.
- GSON excludes transient and static fields, and can exclude others using excludeFieldsWithModifiers().
- JSON supports numbers, strings, booleans, null, arrays, and objects.
- JSON StreamParsers are very low-level and iterate through JsonEvent tokens. They're good for not having to store all the data and getting efficient random access.
- A DOMParser parses a JSON object as a tree in one pass and returns a traversable tree structure. Create a tokener, then wrap it in a JSON object/array depending on the root of the JSON.
- JsonObjects have toString methods for converting to JSON text.
- Serialization converts an object into bytes, such as a string.
- To serialize, use a GsonBuilder. To deserialize, use a Gson object.
- To add a dependency, go to File > Project Structure > Modules > Dependencies > Add > Library > From Maven > Search.
- Gson type adapters allow for customization and special circumstances, such as if Gson can't figure out how to deal with an object.
- Register a type adapter using gson.registerTypeAdapter(class, new adapter instance)
- Use gson.getAdapter() to get gson's internal adapter, then make a type adapter for subclasses with a switch statement and cast a superclass to the subclass.
- Client is bridge between user and server, server is bridge between client and db.
- A client connects, creates and sends a request to the server, the server does what is requested, sends a response, the client takes that and gives it to the user.
- API: Functions and classes that can be called to use external functionalities not developed by you.
- Software Design: Single Responsibility Principle, avoid code duplication, information hiding/encapsulation.
- Endpoint: A function people can call from the web.
- Model classes: Model the real world, store data, implement core algorithms. Stores data in memory.
- Data access classes (DAO): Perform CRUD (create, read, update, delete) operations on a database.
- Service classes: Use DAOs and model classes to perform application functions.
- Handler Classes: Parse JSON requests, turn them into objects, call the services, receive the response, and send it back to the client as JSON.
- GET: Retrieve data. POST: Submit data. PUT: Replace data. DELETE: Delete data.
- curl: Universal command-line program for interacting with URLs. Does GET by default. 
- -X specifies method, such as POST. -v is verbose. -d '{json}' allows you to send request data. -H lets you specify headers. -o file outputs to file. -D dumps headers to a file.
- In class declarations, putting one or more comma-separated strings in <> will make it a generic type that can be used throughout the class.
- Generic types cannot be instantiated with primitive types. Wrappers must be used.
- When constructing a generic object, the type parameters can be excluded from the constructor since they're declared with the variable.
- Methods can have generic types. If not in a generic class, the <T> is put right before the return type in the method declaration.
- Generic type is inferred in method calls, but can be specified, like Arrays.<String>swap(...)
- Generic types can be given boundaries by saying something like <T extends Cloneable & AutoCloseable>. If one of the bounds is a class (there can be only one), it must be first.
- Generic types are invariant, not covariant.
- ? is used as a wildcard, if you only use the superclass and don't reference the subclass. This means you can't mutate anything or add objects, etc.
- ? super Class is an arbitrary supertype of Class, just as ? extends Class is an arbitrary subtype.
- PECS: Producer extends, consumer super. Anything that produces data uses `extends`, anything that consumes data uses `super`.
- For very generic operations, you can use just ? wildcard. ? cannot be used as a type, but if you use a helper method with a normal generic type, you can get around it.
- Generic types can be passed to superclass arguments such as Class<T> extends ArrayList<T>. Extending non-generic types can just use those types and not have any generics on the subclass.
- Interfaces can also use generics.
- Lambdas: (params,...) -> {code}. Type is optional for params.
- Lambdas in Java can only be put into a variable whose type is a functional interface. They can be passed in place of functional interfaces as well.
- At runtime, JVM infers types, automatically constructs a class for the expression, and passes the class as a method call.
- Functional interfaces are any interfaces with one abstract method.
- Returns in lambdas are only necessary for more than one statement.
- Predicate<T> takes a function to test, and returns whether the parameter causes that to be true or false.
- If a lambda calls a single method on a single given parameter, you can use a method reference, such as System.out::println in place of the lambda expression. The :: specifies the method reference.
- For static method references, do ClassName::methodName. For instance methods, do objectName::methodName. 
- (x,y) -> x.methodName(y) becomes ClassName::methodName. To invoke the constructor, do ClassName::new
- Use :name and req.params(":name") to use parameters from URL. * is a wildcard in URL and is accessed by `req.splat()[i]`.
- req.body() is a string of the body. req.headers() is a map of headers and values. req.header(name) gets a specific header.
- res.body(object) sets the body. res.status(200) sets the status code. res.headers() sets headers. Handlers return res.body() by convention.
- Setting the static file location in spark must be done before mapping routes.Spark.staticFiles.location(pathString). The path is relative to the resources directory.
- Configure the 404 not found page with Spark.notFound(htmlString) or notFound((req, res) -> method to read from a file).
- Spark.before(lambda with req and res) and .after(lambda with req and res) allow you to run code before and after handlers. The first param can be a pattern matching string to restrict the paths. Spark.halt(status, string) allows you to throw errors.
- Method names should describe everything they do. Avoid useless verbs, don't overabbreviate, follow conventions.
- Create new methods to decompose algorithms, reduce duplication, or avoid deep nesting.
- Lots of comments may mean a method needs to be decomposed.
- Methods should use all parameters, not use too many parameters (<7), order as in, in-out, out.
- Initialize variables when they're declared, declare them near where they're used. Make sure counters are incremented.
- Groups of closely related statements should be separated by blank lines.
- Expressions should be parenthesized. Operands and operators should have spaces between them.
- Separate conditions on separate lines. Expressions may be separated into well-named submethods.
- Include spaces between method parameters.
- Declare each variable on a separate line.
- Wrap between 80 and 120 characters. Break on commas, equals, 
- Write pseudo-code so that it is not language-specific, but it captures all pertinent details.
- First character of class name is upper, first character of method and variable names are lower.
- Constants are all caps with words separated by underscores.
- Don't differentiate variable names by capitalization or have similar names for different things. 
- Avoid words that are commonly misspelled or characters that look similar. Avoid digits in names.
- Abbreviate consistently, remove vowels or clip, create names you can pronounce and abbreviate consistently.
- IntelliJ can format in code menu. Selecting a directory and running the reformat will reformat all code in a directory.
- In testing, individual parts and subsystems should be verified on their own and then assembled.
- Unit (class) tests should be written by the developer and run often to catch new bugs.
- Each test is a @test method. @BeforeAll, BeforeEach, AfterAll, AfterEach allow methods for setup/cleanup.
- Assertions.assert...() is how you run checks.
- @Timeout gives a time limit.
- Code coverage only measures code executed, not expected results.
- Branch coverage checks branches of if/else. Function coverage checks if any functions were left out.
- Strive for 100% coverage.
- Artificial primary keys are usually better at the cost of readability and requiring joins. Primary keys can span many rows.
- Foreign keys refer to primary keys in other tables.
- In UML, a box is a class, the top is the name, middle is the variables, bottom is the methods. Solid line is inheritance. 
- Horizontal partitioning: Each concrete class is a table. Vertical partitioning: Each concrete and abstract class is a table. Unification: Subclasses are all merged into one big table.
- SQL supports CHAR(n), VARCHAR(n), BIT(n), BIT VARYING(n), INTEGER, SMALLINT, FLOAT, REAL, DOUBLE, NUMERIC/DECIMAL(precision, scale), BLOB (binary large object), CLOB, DATE, TIME, TIMETZ (time zone), TIMESTAMP, TIMESTAMPTZ types.
- Try with resources variables must be declared inside the parentheses, and to enlarge the scope you can have a separate outside variable.
- To use database, create connection url, try with resources for the connection, start transaction, try with resources to prepare a statement, execute the statement and save to a ResultSet, while hasNext use getInt/String/...(index or column name) to get values from each row (STARTING AT 1), catch errors, commit/rollback.
- To update or use user-provided values, put question marks in the SQL string and use statement.setString/Int/...(index starting at 1, value).
- statement.executeUpdate returns # of rows affected.
- To retrieve auto generated keys, add a parameter to the prepared statement, Statement.RETURN_GENERATED_KEYS, and use statement.getGeneratedKeys in a try with resources.
- ResultSet pointers begin one above the first row, so .next() must be called.
- When rolling back, check if connection is null first.
- To give a user permissions to access the database, CREATE USER 'username'@'url' IDENTIFIED BY 'password'; GRANT ALL ON database.* to 'username'@'url'
- getConnection can take a third parameter, with the string, username, and password.
- Begin a transaction with connection.setAutoCommit(false);
- To reset auto increment, ALTER TABLE tableName AUTO_INCREMENT = 1
- When testing databases, clean up or roll back after each test.
- To start and stop MySQL in Linux, use sudo systemctl status/start/stop mysql.
- New users in SQL must be granted permissions.
- Step over runs a method, step into goes into a method.
- Right clicking a set breakpoint allows us to write java code as a conditional boolean expression for the breakpoint to stop on.
- Watches allow us to write java code to run at any breakpoint.
- Under Run > View Breakpoints, you can view all breakpoints or set exception breakpoints, including for specific exception types.
- Caller/Class filters: Only pause on the breakpoint if it comes from a specific method/class
- TODO: run tests, create tests, check quality, fix, submit.