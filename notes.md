# Chess Project Notes

- Use git mv instead of mv to rename/move files, use git rm to remove files. git rm --cached removes a file from
  repository only.
- Math methods allow for safer calculations, bigger numbers.
- final keyword declares a constant variable. It must be declared by the end of the constructor.
- Variables must be initialized before use.
- A package is a set of related classes.
- Static methods are not attached to any object.
- Casting is done by adding (type) to the beginning ex. (float) 3.14
- Use .equals() to compare strings, not ==, except for checking nullity.
- Integer.toString() converts an int to a string, Integer.parseInt() converts a string to an int.
- Strings are immutable.
- Adding \s to the end of a string preserves trailing spaces.
- var declaration allows for generic typing.
- To read input, create a new Scanner(System.in).
- scannerName.nextLine() reads next line, next() reads next word, nextInt(), etc.
- System.console() is slightly safer because of array storage overwrites.
- System.out.println() prints with newline, print() prints with no newline.
- Printf format string: % precedes a one-letter type identifier (f,s,d, etc.), .#f with a number allows shortened
  precision.
- Using L/f/d ending tags for long/float/double literals saves runtime and prevents errors.
- String.format() can use formatted strings to combine/format strings.
- Using the new String() constructor negates the benefits of interning/string optimization. 
- Special characters: \n, \t, \", \', \\, \b, \uXXXX
- String concatenation is inefficient because it creates new strings, so use a StringBuilder.
- If, else if, else are normal, can be shortened with ? : .
- Constructors have no return type, have the same name as class.
- StringBuilder class allows you to modify the string over time.
- Arrays are allocated similar to cpp, but the type is Type[] instead of Type*.
- Switches map inputs to outputs : switch (input) { case value[, value2, ...] -> output var or statement; ... default ->
  {if it's a block, it must have a yield.} } Nulls can cause errors, so have a case null. Switches can fall-through (
  execute following cases until stopped) by using : instead of -> and using yield or break to stop falling.
- Labeled break statements can jump out of multiple loops. Syntax: breakLabel: {code} break breakLabel;
- Variables in overlapping scopes must have unique names.
- All arrays have default values, except for objects, where the array is full of null references.
- Arrays have fixed sizes, ArrayLists don't.
- Classes can be typed like C++.
- Elements can be added with .add([index], val) and removed with .remove([index], val), .get(index) gets a value, .set(
  index, value) sets a value.
- ArrayLists cannot have primitive types, so they use wrappers, such as Integer. .equals() must be used to check
  equality with these, as == compares references.
- Arrays are passed by reference, so separating them requires using Arrays.copyOf(array, length).
- To copy an ArrayList, you can use new ArrayList<type>(arrayList);, or List.of(array).
- Arrays have methods like fill and sort, to use these for ArrayLists use Collections class.
- Args start at 0, without the program name included.
- Arrays.deepToString(array) prints nested lists.
- Each function must specify publicity and return type, and if it is static.
- Varargs are declared as the last parameter using method(type... name)
- InputStream and OutputStream objects are created using Files.newInputStream(path);
- stream.read() reads a single byte, .readAllBytes() reads all bytes (can also be done with Files.readAllBytes(path)),
  or read N number of bytes with .readNBytes(), skipping N bytes with skipNBytes()
- .write() can write bytes/byte arrays, but it must be closed, which can be done using a try-with-resources statement.
  An input stream can be transferred to an output stream by using in.transferTo(out). Files can be copied using
  Files.copy(path, out)
- Encoding can be specified with a Charset object, found in StandardCharsets or with Charset.forName("name")
- Text can be read using a reader, such as with a new InputStreamReader(stream, charset). Short text can be read with
  Files.readString(path, charset), or a sequence of lines as Files.readAllLines(path,charset). Large files can be
  processed as a Stream<String> with Files.lines(path, charset) and a try-with-resources. To read numbers or words, use
  a scanner and its delimiter.
- To read from a file, use Files.newBufferedReader(). To read from a non-file, wrap an inputStream in a new BufferedReader(stream).
- To write text, use an OutputStreamWriter(stream, charset) and out.write(str). For a file, use Files.newBufferedWriter(path, charset).
- For convenience, use a new PrintWriter(streamWriter) to get print methods.
- To write a preprepared string, use Files.write/writeString(path,string,charset,[StandardOpenOption.APPEND])
- You can lock files using FileChannel and FileLock classes.
- File paths can be created using the Path.of() method.
- Paths can be combined using path.resolve(secondPath). path.relativize returns the relative path from one to another.
- Working directory can be fetched using System.getProperty("user.dir").
- To create a new directory, use Files.createDirectory(path). For multiple, use Files.createDirectories(path). To create a file. use Files.createFile(path). Files.exists checks if it exists. Temp files/directories can be created using createTempFile(path, prefix, suffix), etc.
- To copy, use Files.copy(from, to). To move, use Files.move(from, to). Replace existing and copy attributes can be included as params with StandardCopyOption.REPLACE_EXISTING, etc.
- Files.delete(path) deletes a file.
- Files.list(path) lists all files as a Stream of paths, should be opened as try-with-resources. Depth-first.
- Imports don't increase size of compiled files. They appear after package but before class declarations. * imports all packages, but not subpackages. No import is needed for classes in java.lang or in the same package.
- Classpath manages directories for packages
- Variables can only store objects by reference. Mutators modify the original object, while accessors return new ones.
- Parameters are always passed by value.
- Overloaded methods are multiple methods with the same name but different parameters.
- Instance variables are automatically set to 0/false/null.
- Default values are specified when a variable is initialized.
- Records are immutable public classes for simple implementations
- Static initialization blocks can initialize a static variable upon creation of the class. Static variables are class variables, the same between instances.
- Not specifying public or private gives an item package access - everything in the package can use it.
- Import static allows you to import static methods and variables.
- Inner classes have access to all outer methods and variables.
- Constructors invoke each other with this() and the parent's constructor with super(); Constructors have no return type and the name matches the class.
- Inheritance: is-a, use the keyword "extends". All instance variables are inherited, even private ones. All non-private, non-static methods are inherited.
- To override a method, you must have the same arguments, return type, same or looser access modifier, and same or more specific exceptions. Overridden methods can be called using super, and @Override is used as a sanity check. Children must be substitutable for parents.
- Final methods can't be overridden.
- If methods are declared in an enum, a semicolon must follow the values that precede the method.
- Classes: Keep data private, one responsibility per class, classes have noun names while methods have verb names, static methods should be used sparingly.
- Records need all parameters, have only one constructor, have automatic getters, equals, hashCode, and toString methods.
- Getters in records are just the field names e.g. p.name().
- To change records, add a method inside the braces that returns a new record with updated data.
- Exceptions are constructed with `new` and the parameter being an error message. `throw` throws an exception.
- Errors are from the language, exceptions are from the programmer.
- Unchecked exceptions are subclasses of RuntimeException, and all other exceptions are checked.
- Unchecked exceptions are not checked during compilation. Checked exceptions are used when failure is anticipated. Unchecked exceptions are the programmer's fault.
- You can make your own exception classes by extending Exception, RuntimeException, etc.
- Possible exceptions must be declared for a method in the header using `throws` followed by the exception classes.
- Overwritten methods cannot throw more kinds of exceptions than their parent.
- Catch exceptions using a try-catch statement, with one or multiple handlers. Catch clauses are matched top to bottom, so the most specific exception should come first.
- Try-with-resources ensures open hooks are closed in case of exceptions. Resources must include the AutoCloseable interface. Multiple resources can be separated with semicolons, and they will be closed in reverse order.
- Suppressed exceptions are exceptions caused by another exception or handling of it. You can use methods to find suppressed exceptions and causes of rethrown exceptions.
- `finally` clauses are run after try-catch statements finish. It is only for closing resources, not changing the control flow by returning or breaking or throwing exceptions.
- Use the Thread class's method to set a default uncaught exception handler.
- Crashing is never acceptable!
- Exceptions have a printStackTrace() method that is useful.
- Interfaces define methods that subclasses must implement. They're a set of methods that a class promises to implement. All methods are public. Default implementations in the interface are optional, and methods must be prefaced with the `default` tag in the declaration.
- Unimplemented methods in an interface are called abstract.
- Interface declaration: public interface Name {}. public class ClassName implements Name {}
- Interfaces can be used in place of specific classes for variable types, as long as the class of the object referenced by the variable implements it. All objects, however, must be instances of classes.
- Casting is done by doing `(type) varName`, which can be done to access new methods from the subtype that are not in the supertype.
- `instanceof` is an operator checking if an object is a certain type, and it is null-safe. `varName instanceof typeName` returns a boolean.
- Checking the instance type and then casting can be done with `varName instanceof typeName var2Name` where var2Name is a new variable that can be used immediately.
- Interfaces can extend each other. Classes can implement multiple interfaces.
- Interface variables are automatically public, static, and final.
- To specify which superclass you are using a method from, use SuperClassName,super,method() syntax.
- Private interface methods are possible, but cannot be defaults, so they're only helper methods.
- A generic type is done in angle brackets in declarations and used throughout the class, like `public interface Collections<T>`
- The .compare() method safely compares numbers with regards to overflow, infinite values, and NaN.
- Objects can access private features of any instance of their class.
- Subclasses cannot access private features of superclasses.
- Overriden methods must have the same parameters as the default method. This can be checked using @Override tag.
- Dynamic method lookup means subclass instances assigned to superclass variables will still use the overridden methods of the subclass. Arrays function much the same way, but problems can be caused if superclass types are added to subclass arrays.
- Anonymous subclasses are made with braces after the object `new` statement, usually with modified methods or fields.
- Tagging a class definition with `abstract` means there is a method that subclasses must implement themselves. Objects cannot be created with an abstract class, but variables can have an abstract type.
- `protected` keyword grants package level access and access to subclasses from other packages.
- Sealed classes allow us to permit only certain subclasses or, by default, subclasses in the same file.
- `toString()` converts an object to string representation, to print arrays use `Arrays.deepToString()`
- `Objects.equals()` tests null safe equality.
- Interfaces cannot win over default toString, equals, and hashCode methods.
- The clone method should only be overridden to make deep copies.
- For enums, `valueOf()` is opposite to `toString()`
- `values()` returns an array containing all values of an enum.
- You can add override methods to each value of an enum, but the methods must be declared in the parent and overridden.
- You can use statics in an enum, but they must be declared after everything else in a static initializer.
- Two interfaces for data structures: Collection for collections, and Map for maps.
- Collections have a type parameter, and methods such as add, addAll, remove, removeAll, removeIf, retainAll, clear, size, isEmpty, contains, containsAll, iterator, fill, swap, shuffle, and toArray.
- SequencedCollections additionally have get, add, and remove for the first and last elements, as well as a reversed method to reverse the order.
- Lists have get, set, and remove methods, indexOf, lastIndexOf, replaceAll, sort, of (gives an unmodifiable list containing parameters provided), or subList.
- Arrays that allow fast random access implement the RandomAccess tagging interface.
- A deque is a double ended queue.
- Iterators have the hasNext, next, and remove methods. 
- ListIterators are used with LinkedLists
- Iterators on mutated sets may throw exceptions.
- For maps, use `put(key,value)` to insert a value. `get` gets a value from a key, `getOrDefault` is null-safe. `merge(key, valueToMerge, function)` merges values for things like counters. `computeIfAbsent` allows operations if a value has not yet been added. `forEach` allows you to iterate, and `keySet() values() entrySet()` ive you sets for their respective items. 
- Entries in sets generated by methods of the Map class are passed by reference and will mutate the original map. This can be changed by calling `copyOf()` on the entry.
- LinkedHashMaps retain order.
- Properties collections are used for configs. System.getProperties has lots of useful data.
- BitSet stores a sequence of bits efficiently, but it is not a collection.
- Enums have their own sets and maps.
- Deques are queues with efficient access to both ends.
- Use ArrayDeques for stacks.
- PriorityQueues are a provided class in Java.
- WeakHashMaps allow better garbage collection for references that have been removed everywhere else.
- Lists and sets can have sublists and subsets.
- Collections class has unmodifiable versions of data structures
- The concurrent package is better for concurrency than synchronized views.
- checkedLists allow for errors to be thrown for incorrect objects on insertion instead of retrieval.
- When placing objects in collections, equals() and hashCode() must be overwritten.
- Collections can only store objects, so wrappers are needed for primitives.
- HashSets are faster, TreeSets are less memory.
- Equals and hashCode methods need to be in sync, with the same fields and methodology.
- Sortable classes must implement Comparable, which has compareTo. 
- In compareTo, if two objects are equal, it returns zero. If the object being compared is less, it returns -1. If the object being compared is greater, it returns 1.
- Don't modify an object in a collection in a way that would change its position in the collection. Take it out, modify it, and put it back in.
- Immutable objects don't need to be copied, they can be passed by reference.
- One way to copy an object is to make a copy constructor that takes an object as a parameter and makes a new object that is exactly the same.
- To override `clone()`, a class must implement Cloneable and should probably catch CloneNotSupportedException.
- RuntimeExceptions are for bugs.
- To create a deep copy, make a shallow copy and then clone each mutable member field manually, setting the new object's field equal to the clone.
- When making clones, they must be cast into the correct type, because clone() returns an Object by default.
- Local classes are classes defined inside methods. Local classes are not declared as public or private. Local classes can access the variables of the enclosing scope.
- Define an anonymous class using `new [Interface]() {methods}`. Anonymous classes are only necessary when defining 2+ methods since you can't use a lambda.
- Static classes cannot access any instance variables, including of the outer class.
- Declare things as close as possible to where we use them.
- Variables used in local classes can't be changed after the instance of the class is created, because of garbage collection protection and copying.
- We want to create systems that work, are structured for ease of understanding/maintenance, and can hold up under change.
- Software design is a cycle of planning, implementing, and testing. You can;t cut out any step.
- Abstraction combats complexity. Some classes model real world concepts, some don't.
- Make the public-facing code as simple as possible. They shouldn't need to know what's inside.
- Store and do only what you need.
- Names should convey function and purpose.
- Class and variable names should be nouns, method names should be verbs.
- Each class and method should have one well-defined responsibility. All features should be related to that.
- Break a program into smaller problems, solve each, and them combine them to solve bigger problems.
- System -> Subsystem -> Package -> Class -> Method
- Choose good data structures and algorithms.
- Classes should know as little about each other as possible - low coupling. This reduces ripple changes.
- Everything should be private unless there's a good reason to make it public.
- Protected: Variable/method is only visible within the inheritance tree.
- Don't give away your implementations in names (security reasons).
- Separate an interface and its implementation. Program to interfaces instead of concrete classes.
- Don't repeat yourself.